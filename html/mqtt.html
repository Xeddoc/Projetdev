<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Objets Connectés: MQTT</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_ynov_campus_aix_rvb.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Objets Connectés
   </div>
   <div id="projectbrief">Outils de développement d&#39;objets connectés</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MQTT </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Message Queuing Telemetry Transport</p>
<p>Le protocole Message Queue Telemetry Transport (MQTT) est conçu pour l'échange de messages entre des petits périphériques sur une faible bande passante, ou pour les connexions coûteuses et envoyer des messages de façon fiable. Il utilise TCP/IP. <a href="http://mqtt.org/">http://mqtt.org/</a> MQTT est un protocole ouvert, simple, léger et facile à mettre en œuvre. Ce protocole est idéal pour répondre aux besoins suivants :</p><ul>
<li>Utilisation d’une très faible bande passante,</li>
<li>Utilisation sur les réseaux sans fils,</li>
<li>Faible consommation en énergie,</li>
<li>Rapidité avec un temps de réponse supérieur aux autres standards du web actuel,</li>
<li>Fiabilité,</li>
<li>Utilisation de faibles ressources processeurs et de mémoire.</li>
</ul>
<h2>Publish/Subscribe</h2>
<p>MQTT est un service de publication/abonnement en contraste avec le protocole HTTP et son architecture « request/response ». MQTT se base sur TCP/IP et est extrêmement léger. Il fonctionne sur le principe client/serveur.</p>
<h2>MQTT Broker</h2>
<p>Le point central de la communication est le broker MQTT en charge de relayer les messages des émetteurs vers les clients. Chaque client s’abonne via un message vers le broker : le « topic » (sorte d’information de routage pour le broker) qui permettra au broker de réémettre les messages reçus des producteurs de données vers les clients. Les clients et les producteurs n’ont ainsi pas à se connaître, ne communiquant qu’au travers des topics. Cette architecture permet des solutions multi-échelles.</p>
<p>Le principe d’échange est très proche de celui de Twitter. Les messages sont envoyés par les publishers sur un canal appelé topic. Ces messages peuvent être lus par les subscribers (abonnés). Les topics (ou canaux d’informations) peuvent avoir une hiérarchie qui permet de sélectionner finement les informations que l’on désire.</p>
<p>Chaque client MQTT a une connexion ouverte en permanence avec le broker. Si la connexion s’arrête, le broker bufférise les messages et les émet dès que la reconnexion avec le client est effectuée.</p>
<p>Voici quelques brokers :</p><ul>
<li>Eclipse Mosquitto</li>
<li>CloudMQTT</li>
<li>Thingsboard</li>
<li>ThingMQ <br />
- ThingStudio</li>
<li>CloudMQTT</li>
<li>IBM Bluemix</li>
<li>Heroku</li>
<li>Hivemq</li>
<li>Microsoft Azure IoT</li>
<li>MaQiaTTo <br />
 <h2>Topics</h2>
</li>
</ul>
<p>Un « topic MQTT » est une chaîne de caractères qui peut posséder une hiérarchie de niveaux séparés par le caractère « / ». Par exemple, une information de température du salon pourrait être envoyée sur le topic « maison/salon/temperature » et la température de la cuisine sur « maison/cuisine/temperature ». Le signe « + » est un caractère « wildcard » qui permet des valeurs arbitraires pour une hiérarchie particulière et le signe « # » pour plus d’un niveau.</p>
<p>Par exemple le "topic" ‘/home/salon/temperature’ communiquera les températures du salon si un quelqu'un (object connecté ou application cliente) s’y abonne. La sonde de température présente dans le salon publiera régulièrement la température relevée sur ce topic. Si un publisher s’abonne au topic ‘/home/salon/#’ il recevra toutes les données du salon (on peut imaginer : luminosité, humidité, température ...). S’il s’abonne au topic ‘/home/#’, il collectera toutes les données des sondes de la maison.</p>
<h2>Sécurité</h2>
<p>MQTT permet de sécuriser les échanges à plusieurs niveaux :</p><ul>
<li>Transport en SSL/TLS,</li>
<li>Authentification par certificats SSL/TLS,</li>
<li>Authentification par login/mot de passe.</li>
</ul>
<h2>Qualité de Service (QoS)</h2>
<p>MQTT intègre en natif la notion de QoS. En effet le publisher à la possibilité de définir la qualité de son message. Trois niveaux sont possibles :</p><ul>
<li>Un message de QoS niveau 0 « At most once » sera délivré tout au plus une fois. Ce qui signifie que le message est envoyé sans garantie de réception, (le broker n’informe pas l’expéditeur qu’il l’a reçu et le message)</li>
<li>Un message de QoS niveau 1 « At least once » sera livré au moins une fois. Le client transmettra plusieurs fois s’il le faut jusqu’à ce que le Broker lui confirme qu’il a était transmis sur le réseau.</li>
<li>Un message de QoS niveau 2 « exactly once » sera obligatoirement sauvegardé par l’émetteur et le transmettra toujours tant que le récepteur ne confirme pas son envoi sur le réseau. La principale différence étant que l’émetteur utilise une phase de reconnaissance plus sophistiquée avec le broker pour éviter une duplication des messages (plus lent mais plus sûr).</li>
</ul>
<h2>Bibliothèques MQTT</h2>
<p>Il existe de très nombreuses bibliothèques pour programmer des clients MQTT, et ce pour la plupart des langages (C, C++, Java, JavaScript, PHP, Python ...) et sur la plupart des plates-formes (GNU/Linux, Windows, iOS, Android, Arduino ...).</p><ul>
<li>Eclipse Paho : <a href="https://www.eclipse.org/paho/">https://www.eclipse.org/paho/</a></li>
<li>HiveMQ</li>
<li>Eclipse Mosquitto</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Même si on ne sait pas exactement comment, il semblerait que Facebook utilise des aspects de MQTT dans Facebook Messenger !</dd></dl>
<h2>TP</h2>
<p>Dans ce module, nous allons travailler avec la plateforme Thingsboard : <a href="https://thingsboard.io/">https://thingsboard.io/</a></p><ul>
<li>Rendez vous sur la plateforme de démonstration : <a href="https://demo.thingsboard.io/login">https://demo.thingsboard.io/login</a></li>
<li>Créez vous un compte,</li>
<li>Créez un dispositif avec le <b>Nom</b> et le <b>Type</b> <b>de</b> <b>dispositif</b> que vous souhaitez,</li>
<li>Après avoir cliqué sur le nom de votre dispositif, récupérez le jeton d'accès de votre dispositif depuis l'onglet <b>Détails</b> :<ul>
<li>Copier le jeton d'accès ou</li>
<li>Gérer les informations d'identification, en sélectionnant Access Token comme Type d'authentification</li>
</ul>
</li>
</ul>
<p>Ecrivez un programme qui assurera les fonctionnalités suivantes :</p><ol type="1">
<li>Connexion au serveur MQTT</li>
<li>Envoi de données de télémétrie simulées (v1/devices/me/telemetry) :<ul>
<li>Dans la loop dans un premier temps</li>
<li>Via un Ticker avec un fréquence paramétrable ensuite</li>
</ul>
</li>
<li>Affichage des données de télémétrie dans un tableau de bord</li>
<li>Envoi d'attributs de votre objet au broker à la connexion (v1/devices/me/attributes) :<ul>
<li>Type de matériel : NodeMCU dans notre cas</li>
<li>Le numéro de série récupéré fourni par ESP.getChipId()</li>
<li>Version du firmware</li>
</ul>
</li>
<li>Définissez un actuateur, par défaut la BUILTIN_LED sur la broche 2<ul>
<li>Publier l'état de votre actuateur en attribut à la connexion</li>
</ul>
</li>
<li>Gérer la réception des messages du broker<ul>
<li>Abonnez vous à toutes les commandes RPC (v1/devices/me/rpc/request/+)</li>
<li>Implémentez une callback pour la réception des messages reçus</li>
<li>Implémentez 2 fonctions pour récupérer (getActuatorState) et pour changer (setActuatorState) l'état de votre actuateur</li>
<li>Ajouter sur votre tableau de bord un Control Widget de type Led Indicator pour afficher l'état de votre actuateur</li>
<li>Ajouter sur voter tableau de bord un Control Widget de type Switch Control pour pouvoir changer l'état de votre actuateur</li>
</ul>
</li>
</ol>
<p>Les bibliothèques à utiliser sont les suivantes (préférez l'installation des bibliothèques via l'IDE):</p><ul>
<li>PubSubClient by Nick O'Leary : <a href="https://pubsubclient.knolleary.net/">https://pubsubclient.knolleary.net/</a> <a href="https://github.com/knolleary/pubsubclient/releases/tag/v2.7">https://github.com/knolleary/pubsubclient/releases/tag/v2.7</a></li>
<li>Arduino JSON by Benoit Blanchon : <a href="https://github.com/bblanchon/ArduinoJson">https://github.com/bblanchon/ArduinoJson</a></li>
</ul>
<p>Pour démarrer :</p><ul>
<li>Exemple mqtt_esp8266 de la bibliothèque PubSubClient ou <a href="https://github.com/knolleary/pubsubclient/blob/master/examples/mqtt_esp8266/mqtt_esp8266.ino">https://github.com/knolleary/pubsubclient/blob/master/examples/mqtt_esp8266/mqtt_esp8266.ino</a></li>
<li>Hello World Thingsboard : <a href="https://thingsboard.io/docs/getting-started-guides/helloworld/">https://thingsboard.io/docs/getting-started-guides/helloworld/</a></li>
<li>Thingsboard MQTT API (Telemetry, Attributes &amp; RPC) : <a href="https://thingsboard.io/docs/reference/mqtt-api/">https://thingsboard.io/docs/reference/mqtt-api/</a></li>
</ul>
<p>Fichier <a class="el" href="_my_m_q_t_t_8h.html">MyMQTT.h</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
